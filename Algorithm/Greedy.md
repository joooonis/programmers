# 그리디(Greedy)

그리디 알고리즘(Greedy Algorithm)은 최적해를 구하는 방법 중 하나입니다. 이 알고리즘은 매 단계에서 최선의 선택을 하는 것으로 구성되어 있습니다. 즉, 각 단계에서 가능한 선택 중에서 가장 좋은 선택을 하며, 이러한 선택들이 모여 전체적으로 최적의 해를 구하는 것입니다.

이 알고리즘은 간단하고 직관적이며 구현하기 쉽기 때문에 많은 문제에서 유용하게 사용됩니다. 그러나 이 알고리즘을 사용하여 구한 해가 항상 최적의 해인지 보장할 수는 없습니다.

그리디 알고리즘은 매 단계에서 최적의 선택을 하기 때문에, 해당 선택이 이후에 영향을 미치지 않는 경우에 최적의 해를 구할 수 있습니다. 이러한 성질을 "최적 부분 구조(Optimal Substructure)"라고 합니다. 또한, 선택이 가능한 모든 경우를 탐색하지 않고도 최적의 해를 구할 수 있는 경우에는 "탐욕적 선택 속성(Greedy Choice Property)"을 가진다고 합니다.

그리디 알고리즘은 다음과 같은 절차로 구현할 수 있습니다.

1. 문제에서 선택할 수 있는 항목 중에서 가장 좋은 항목을 선택합니다.
2. 선택된 항목이 문제의 제한 조건을 만족시키도록 문제를 갱신합니다.
3. 모든 제한 조건을 만족시키는 해가 나올 때까지 1, 2 과정을 반복합니다.

예를 들어, 활동 선택 문제(Activity Selection Problem)를 생각해보면, 여러 개의 활동이 주어졌을 때, 겹치지 않는 최대 수의 활동을 선택하는 문제입니다. 이 문제는 그리디 알고리즘을 사용하여 해결할 수 있습니다. 시작 시간을 기준으로 정렬하고, 가장 빨리 끝나는 활동을 선택하고, 이 활동과 겹치지 않는 활동들 중에서 가장 빨리 끝나는 활동을 선택하는 것을 반복합니다.

하지만, 모든 문제에서 그리디 알고리즘을 사용하여 최적의 해를 구할 수 있는 것은 아닙니다. 예를 들어, 배낭 문제(Knapsack Problem)은 그리디 알고리즘을 사용하여 최적의 해를 구할 수 없는 대표적인 예시입니다. 이 문제는 각 물건의 가치와 무게가 주어졌을 때, 배낭의 용량을 초과하지 않으면서 가치의 합을 최대로 만드는 문제입니다. 각 물건을 가치가 높은 순서대로 배낭에 담는 것이 최적의 해가 아닌 경우가 있기 때문입니다.

따라서, 그리디 알고리즘을 사용할 수 있는 문제와 사용할 수 없는 문제를 구분하여 사용해야 합니다.
