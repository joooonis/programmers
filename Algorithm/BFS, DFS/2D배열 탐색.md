# 2차원 배열 탐색

```javascript
function dfs2d(grid, visited, row, col) {
  const ROW = grid.length;
  const COL = grid[0].length;
  // 현재 위치를 방문한 것으로 표시
  visited[row][col] = true;
  // 현재 위치에서 상하좌우 방향을 확인하면서 방문하지 않은 원소를 재귀 호출로 방문
  const dr = [-1, 0, 1, 0]; // row 방향 이동을 위한 배열
  const dc = [0, 1, 0, -1]; // col 방향 이동을 위한 배열
  for (let d = 0; d < 4; d++) {
    const nextRow = row + dr[d];
    const nextCol = col + dc[d];
    // 범위를 벗어나거나 방문한 원소는 건너뜀
    if (
      nextRow < 0 ||
      nextRow >= ROW ||
      nextCol < 0 ||
      nextCol >= COL ||
      visited[nextRow][nextCol]
    )
      continue;
    // 재귀 호출로 다음 위치 방문
    dfs2d(grid, visited, nextRow, nextCol);
  }
}
```

## BFS

이 함수는 인자로 2차원 배열(matrix)와 시작 지점(start)을 받습니다. 시작 지점에서부터 상하좌우로 연결된 모든 점들을 BFS 알고리즘을 이용해 탐색하며, 각 점이 방문되었는지 여부를 boolean 타입으로 저장한 visited 배열을 반환합니다.

```javascript
function bfs(matrix, start) {
  const rows = matrix.length;
  const cols = matrix[0].length;

  // 방문 여부를 저장하는 2차원 배열
  const visited = Array(rows)
    .fill()
    .map(() => Array(cols).fill(false));

  // 상하좌우 이동을 위한 델타 배열
  const dx = [1, -1, 0, 0];
  const dy = [0, 0, 1, -1];

  // 시작 지점 큐에 삽입
  const queue = [start];
  visited[start[0]][start[1]] = true;

  while (queue.length > 0) {
    const [x, y] = queue.shift();

    // 상하좌우 이동
    for (let i = 0; i < 4; i++) {
      const nx = x + dx[i];
      const ny = y + dy[i];

      // 인접한 점이 배열 내부에 있는지 확인
      if (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {
        // 아직 방문하지 않은 점이면 큐에 삽입
        if (!visited[nx][ny]) {
          queue.push([nx, ny]);
          visited[nx][ny] = true;
        }
      }
    }
  }

  return visited;
}
```

예를 들어, 아래와 같은 2차원 배열을 탐색한다고 가정해봅시다.

```javascript
const matrix = [
  [0, 1, 0, 1],
  [1, 0, 1, 0],
  [0, 1, 0, 1],
  [1, 0, 1, 0],
];
```

시작 지점이 (1, 1)일 때, 함수를 호출하면 아래와 같은 결과를 얻을 수 있습니다.

```javascript
bfs(matrix, [1, 1]);
// => [
//   [false, true, false, true],
//   [true, false, true, false],
//   [false, true, false, true],
//   [true, false, true, false]
// ]
```

### DFS

아래 코드에서 matrix는 2차원 배열이며, 각 요소는 해당 위치의 노드 값으로 이루어져 있습니다. startRow와 startCol은 탐색을 시작할 시작 위치입니다. visited 배열은 방문한 노드를 체크하기 위한 배열로, 초기값은 모두 false로 설정됩니다. queue 배열은 BFS 탐색을 위한 큐입니다. while문 내에서는 큐에 요소가 있을 동안 BFS 탐색을 반복합니다. 상하좌우 이동을 하면서 방문하지 않은 노드를 큐에 추가하고 visited 배열을 갱신합니다.

```javascript
function bfs(matrix, startRow, startCol) {
  const numRows = matrix.length;
  const numCols = matrix[0].length;
  const visited = Array(numRows)
    .fill()
    .map(() => Array(numCols).fill(false));

  const queue = [];
  queue.push([startRow, startCol]);
  visited[startRow][startCol] = true;

  while (queue.length > 0) {
    const [row, col] = queue.shift();
    // 이 부분에서 row, col 좌표를 이용해 원하는 작업을 수행합니다.

    // 상하좌우 이동
    const dr = [-1, 1, 0, 0];
    const dc = [0, 0, -1, 1];
    for (let i = 0; i < 4; i++) {
      const newRow = row + dr[i];
      const newCol = col + dc[i];
      if (newRow < 0 || newRow >= numRows || newCol < 0 || newCol >= numCols) {
        continue;
      }
      if (visited[newRow][newCol]) {
        continue;
      }
      if (matrix[newRow][newCol] === 0) {
        continue;
      }
      queue.push([newRow, newCol]);
      visited[newRow][newCol] = true;
    }
  }
}
```
