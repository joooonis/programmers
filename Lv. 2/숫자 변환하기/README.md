# 문제

[숫자 변환하기](https://school.programmers.co.kr/learn/courses/30/lessons/154538)

# 풀이

BFS 또는 Dynamic Programming으로 풀 수 있습니다.

### BFS

- BFS 알고리즘을 사용하여 x에서부터 가능한 모든 연산을 수행하여 y를 만들 수 있는지 확인하고, 만들 수 있다면 필요한 최소 연산 횟수를 반환합니다. visited 배열을 사용하여 중복 계산을 방지합니다.
- 시간 복잡도는 BFS 알고리즘에 따라 O(y)입니다.
- queue를 사용하여 구현합니다.

1. 우선, x와 y가 같은 경우는 0을 반환하고 함수를 종료합니다.

```
if (x === y) {
return 0;
}
```

2. 방문 여부를 확인하기 위해 visited 배열을 생성합니다. 이 때, y보다 2배 이상인 경우도 고려하여 visited 배열의 길이를 2\*y+1로 설정합니다.

```
const visited = Array.from({ length: 2 * y + 1 }, () => false);
```

3. BFS 알고리즘을 구현하기 위해 queue 배열을 생성하고, x와 0을 삽입합니다.

```
const queue = [[x, 0]];
```

4. x를 방문한 것으로 표시하기 위해 visited[x]를 true로 설정합니다.

```
visited[x] = true;
```

5. queue 배열이 빌 때까지 다음 과정을 반복합니다.

```
while (queue.length > 0) {
// ...
}
```

6. queue 배열에서 첫 번째 요소를 가져옵니다. 이 요소는 현재 자연수와 현재 연산 횟수를 나타냅니다.

```
const [curr, count] = queue.shift();
```

7. 현재 자연수가 y와 같은 경우, 현재 연산 횟수를 반환합니다.

```
if (curr === y) {
return count;
}
```

8. 현재 자연수에 n을 더한 값이 y보다 작거나 같고 방문하지 않은 자연수인 경우, queue 배열에 삽입하고 방문 여부를 true로 설정합니다.

```
if (curr + n <= 2 _ y && !visited[curr + n]) {
queue.push([curr + n, count + 1]);
visited[curr + n] = true;
}
```

9. 현재 자연수에 2를 곱한 값이 y보다 작거나 같고 방문하지 않은 자연수인 경우, queue 배열에 삽입하고 방문 여부를 true로 설정합니다.

```
if (curr _ 2 <= 2 _ y && !visited[curr _ 2]) {
queue.push([curr * 2, count + 1]);
visited[curr * 2] = true;
}
```

10. 현재 자연수에 3을 곱한 값이 y보다 작거나 같고 방문하지 않은 자연수인 경우, queue 배열에 삽입하고 방문 여부를 true로 설정합니다.

```
if (curr _ 3 <= 2 _ y && !visited[curr * 3]) {
queue.push([curr * 3, count + 1]);
visited[curr * 3] = true;
}
```

11. 만약 y를 만들 수 없는 경우, -1을 반환합니다.

```
return -1
```

현재 구현된 BFS 알고리즘은, 가능한 모든 자연수를 탐색하므로 시간 복잡도가 O(y)입니다. 따라서, y가 매우 큰 경우에는 시간 초과가 발생할 가능성이 높습니다.

## 동적 프로그래밍

동적 프로그래밍을 사용하여 x를 y로 변환하기 위한 최소 연산 횟수를 구합니다.

먼저 dp 배열을 생성합니다. dp[i]는 i를 만들기 위해 필요한 최소 연산 횟수를 나타내는 배열입니다. 이 때, y까지의 값을 구하기 위해 dp 배열의 크기를 y + 1로 설정하고, 모든 값들을 무한대(Infinity)로 초기화합니다.

그리고 x를 만들기 위해 필요한 최소 연산 횟수는 0이므로 dp[x]를 0으로 설정합니다.

이제 x부터 y까지의 모든 자연수 i에 대해서 아래의 과정을 반복합니다.

1. dp[i]가 무한대(해당 숫자를 만들 수 없음)라면, 다음 자연수로 넘어갑니다.
2. x에 n을 더한 값(i + n)이 y보다 작거나 같다면, dp[i + n]과 dp[i] + 1 중 작은 값을 dp[i + n]에 할당합니다. 이는 i + n을 만들기 위해 i를 만든 후 n을 더하는 연산이 필요하기 때문에, dp[i] + 1의 값으로 dp[i + n]을 업데이트하는 것입니다.
3. x를 2배한 값(i _ 2)이 y보다 작거나 같다면, dp[i _ 2]와 dp[i] + 1 중 작은 값을 dp[i * 2]에 할당합니다.
4. x를 3배한 값(i _ 3)이 y보다 작거나 같다면, dp[i _ 3]와 dp[i] + 1 중 작은 값을 dp[i * 3]에 할당합니다.
5. 위 과정을 모두 수행한 후, dp[y]를 반환합니다. 만약 dp[y]가 Infinity라면, y를 만들 수 없는 경우이므로 -1을 반환합니다.

이 방법을 이용하면 시간 복잡도는 O((y-x) \* 3)으로, x와 y의 범위에 따라 다르지만, 상대적으로 적은 시간에 문제를 풀 수 있습니다.

# 결과

정확성 : 100.0
합계 : 100.0 / 100.0
